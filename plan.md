# 并发编程学习/教学计划（基于本仓库 + Codex + JDK 21）

## 目标与产出

- 目标：系统掌握 Java 并发的核心概念、常见陷阱与工程落地选型（锁、AQS、并发容器、线程池、原子类、工具类）。
- 每章产出：章节笔记 `notes/NN.<标题>.md`（一页纸复盘 + 错题/误区清单 + 场景题 + 实验复盘）+ 最小实验 `labs/NN-xxx/`。
- 题库：`notes/questions.md`（只放题不放答案，用于复测与间隔重复）。

## 环境与约定

- JDK：21（建议统一使用同一套 JDK，运行前 `java -version` 确认）
- 实验目录：`labs/`（每章一个目录：`labs/01-...`、`labs/02-...`…）
- 笔记与题库：`notes/`（题库：`notes/questions.md`；每章笔记：`notes/NN.<标题>.md`）
- “只做可验证结论”：实验输出必须包含参数、结果校验、耗时；避免用不稳定现象推结论。

## 每章标准流程（建议 60–120 分钟/章）

1) **阅读**：通读章节 `.md`，标注“不懂/想验证/想反驳”的点（3–5 个）。
2) **Codex 自测（闭卷两段式，默认先做 5 题）**：先让 Codex **只出题不出答案**（出 10 题，但你首轮只做 5 题，建议至少 2 道“场景选型题”）；你计时闭卷作答；再把答案发回给 Codex 按要点评分并纠错（建议 `0/1/2` 计分）。**首轮 ≥ 8/10 再做剩余 5 题；否则先复盘错题并按 `D+1/D+3/D+7` 复测错题**。最后（可选）再让 Codex 输出 `5 个常见误区清单 + 5 句话总结` 用于查漏补缺（放到自测之后再看）。
3) **最小实验（MRE）**：每章 1–2 个实验（能跑、能复现、能解释）。把代码与输出交给 Codex 复盘。
4) **一页纸复盘**：写下本章：关键词、3 个结论、2 个误区、1 个“我会怎么用在项目里”。并把错题做一次“二次复述”，以及按 `D+1 / D+3 / D+7` 间隔复测（只测错题即可）。

> 自测与笔记的高性价比原则
>
> - 不要把“10 题题目 + 全量标准要点”原封不动抄进笔记；优先记录**错题/不确定题**与**漏点**。
> - 自测题默认“先做 5 题再升级到 10 题”：首轮满分 10（5 题 * 0/1/2），≥ 8 分再做第二轮；没达标就优先复盘错题与间隔复测。
> - 每道错题只记：`漏点清单（3–5 条） + 一句话正确结论 + 触发条件/边界/反例`，下次复测只测错题即可。
> - 如果想长期积累题库：维护 `notes/questions.md`（只放题不放答案），答案要点只放在“错题区”。
> - `5 个常见误区清单 + 5 句话总结` 建议在“评分纠错/二次复述”之后再看，用来查漏补缺；不要原样复制进笔记：误区只收录你真实踩过/差点踩的，5 句话总结更推荐你自己写（可选）。
> - 若章节内容“重点/非重点”差异明显，推荐使用 **方式B（先提炼重点→你确认→再出题）**，避免自测被非重点内容干扰（见下方提示词模板）。
> - 读前可用“导航版重点清单”帮助阅读定位：只提炼小节标题+关键词（不展开、不解释、不下结论），避免读前摘要造成“看懂错觉”。

> 笔记协作流程（推荐顺序）
>
> 1. 你先写“原始草稿”（允许粗糙，越真实越好）。
> 2. Codex **重排与精简**（只做归类/去重/压缩到模板结构，**不要补充新知识**，避免改变语义）。
> 3. 你先过一遍重排版，修正明显不对/不顺的地方。
> 4. Codex **对照本章内容检查**：只给“修改建议 + 应补要点标题”，不要直接重写全文（按 概念/机制/边界/工程实践 分类）。
> 5. 你把建议落到笔记里（最后版本必须由你自己改，才算真正掌握）。
> 6. 可选：把你修改后的最终版发给 Codex 做一次“最后校对”（只查自相矛盾/边界写反/遗漏关键步骤）。
>
> 暂存问题（真解不出来时）怎么处理
>
> 1. 先“可追踪化”：在问题后补齐 4 个字段：`[暂存][优先级P1/P2][前置: <概念/章节>][下次回看: <时间/章节>]`。
> 2. 再“可复盘化”：补 3 行信息：我当前猜想（1 句）/ 卡点类型（概念/机制/边界/源码）/ 已尝试证据（对应小节/实验现象/输出摘要）。
> 3. 设“回看触发点”：常用两种：学完某章后回看（它是前置）/ 每周末清算暂存区（每次只清 2–3 个 P1）。
> 4. 把大疑问拆成“小问题”：优先拆成可验证的是非判断、对比实验、最小代码片段（能实验验证就先实验）。
> 5. 仍不行就升级：标记“需要源码/规范佐证”，后续专门对照 JDK 源码或规范再解决。

> Codex 提示词模板（复制即用）
>
> 自测（出题/评分/复测）
>
> - `基于本章内容出10道自测题：至少3道必须是“场景选型题”，每道都要求我回答：选型/原因/代价（或边界）；其余题目在概念/机制/代码阅读之间尽量均衡。先不要给答案或答案要点，也不要输出常见误区清单或5句话总结。请给每题编号（建议：CHNN-Q01…CHNN-Q10）并标注题型（概念/机制/场景/代码阅读）。最后只给出“首轮建议先做的5题题号”（至少包含2道场景题），不要给理由。`
> - `这是我的作答（如下）。请逐题给出：得分（0/1/2）+扣分点（我漏了什么/错在哪）+纠正后的标准答案要点（条目化、可复述）。请给出总分（若我只答了5题，则按/10；若答了10题，则按/20）。最后汇总：错题清单 + 我下一次复测应优先问自己的5个问题，并告诉我是否建议进入第二轮（标准：首轮≥8/10再做剩余5题）。`
> - `基于本章内容（结合我的错题/扣分点），输出：5个常见误区清单（只写误区本身）+5句话总结。要求：不提前泄露本章自测题的标准答案展开，只做复盘提示。`
> - `这是我D+1（或D+3/D+7）复测的错题作答（如下）。请只纠正错题并更新错题清单（按“概念/机制/边界/工程实践”分类）。`
> - `根据我错题漏点清单（如下），生成10道针对性复测题：只出题不出答案，尽量场景化。`
>
> 自测（方式B：先提炼重点→你确认→再出题）
>
> - `基于本章内容先提炼“重点清单”10条：按P0/P1分级（P0=必须掌握，P1=理解即可）；每条附：对应小节标题/关键词。先不要出题，也不要给答案要点。`
> - `我确认的重点清单如下（粘贴）。请只基于这些重点出10道自测题：至少3道必须是“场景选型题”，每道都要求我回答：选型/原因/代价（或边界）；其余题目在概念/机制/代码阅读之间尽量均衡。先不要给答案或答案要点，也不要输出常见误区清单或5句话总结。请给每题编号（CHNN-Q01…CHNN-Q10）并标注题型。每题标注“覆盖的重点编号”。最后只给出“首轮建议先做的5题题号”（至少包含2道场景题），不要给理由。`
>
> 读前导航（可选，避免被摘要干扰）
>
> - `在我阅读本章正文之前，请先给“导航版重点清单”10条：P0/P1分级；每条只写小节标题+关键词，不要解释、不要展开、不要给答案要点、不要总结。`
>
> 笔记（重排/检查/终稿）
>
> - `这是我本章原始笔记（如下）。请按“每章记录模板”重排并精简：尽量保留原话，不要补充新知识；如需删减/合并，请在末尾列出“删减/合并清单”。`
> - `请对照本章内容检查我这份笔记：只输出“修改建议 + 应补要点标题”，不要重写全文；按概念/机制/边界/工程实践分类，并指出我笔记里对应的原句（引用一小段）以便我定位修改。`
> - `这是我修改后的最终版笔记（如下）。请只做最后校对：检查是否自相矛盾、边界写反、缺关键步骤；不要新增内容。`
> - `这是我暂存的问题（如下）。请先问我3个澄清问题，再给出2种可能解释（各3-5条要点），并分别给一个最小可运行实验/验证步骤。最后告诉我：学到哪一章后再回看更合适。`
>
> 实验（设计/复盘）
>
> - `帮我设计一个最小可运行Java实验来验证：<结论>。要求：参数可调、输出可复盘、避免不稳定现象。`
> - `这是我的代码与输出（如下），请解释现象，并说明我能/不能从这个实验推出哪些结论。`

## 推荐进度（6 周路线，可按节奏拉长）

### 第 0 周：准备与基线

- 确认 JDK 21、生效的 `PATH/JAVA_HOME`、能 `javac`/`java` 运行。
- 跑通第 1 章实验：`labs/01-concurrency-pros-cons/`。
- 在 `notes/` 下开始记录：每章一份笔记 + 维护题库 `notes/questions.md`（题库只放题，答案放在每章“错题区”）。

### 第 1 周：基础与 JMM（01–03）

- 01 并发的优缺点：收益边界、代价清单、风险清单（已提供实验）。
- 02 线程状态/基本操作：创建方式、状态流转、interrupt 语义、join/daemon。
- 03 JMM 与 happens-before：可见性、有序性、重排序；建立“哪些行为由规范保证”。

实验建议：
- 线程状态：`WAITING/TIMED_WAITING/BLOCKED` 的最小复现与解释。
- JMM：用 `volatile`/非 `volatile` 的可见性对比（注意：避免用“死循环卡住”当唯一证据，需增加超时/统计）。

### 第 2 周：关键字与锁（04–07）

- 04 `synchronized`：monitor、可重入、happens-before、锁优化概念（以语义为主）。
- 05 `volatile`：可见性、禁止重排、与原子性边界。
- 06 `final`：初始化安全、发布与逃逸。
- 07 原子性/可见性/有序性总结：把概念映射到工具选择（锁/原子类/volatile）。

实验建议：
- `volatile` 的“可见但不原子”与 “原子但不复合”案例（如 check-then-act）。

### 第 3–4 周：Lock 体系与 AQS（08–13）

- 08–09 AQS：state/队列/条件队列、acquire/release 语义、共享/独占。
- 10 `ReentrantLock`：公平/非公平、可中断、tryLock、Condition。
- 11 `ReentrantReadWriteLock`：读写分离、饥饿与适用场景。
- 12 `Condition`：await/signal 的正确用法（必须 while 重新检查条件）。
- 13 `LockSupport`：park/unpark 与中断标记。

训练重点：
- 写出“正确的条件等待模板”（while + condition + state）。
- 用 3–5 个场景题练选型：synchronized vs Lock；RWLock 适合/不适合什么负载。

### 第 5 周：并发容器（14–20）

- 14 `ConcurrentHashMap`（JDK8 语义）：并发度、CAS/锁混合、迭代弱一致性。
- 15 `ConcurrentLinkedQueue`：无锁队列、吞吐与一致性。
- 16 `CopyOnWriteArrayList`：读多写少场景、内存与写放大。
- 17–18 `ThreadLocal`：使用边界、内存泄漏成因与最佳实践（及时 remove）。
- 19–20 `BlockingQueue`：背压、生产者消费者、不同队列权衡。

实验建议：
- ThreadLocal：用线程池复现“忘记 remove 导致对象滞留”的最小案例（可用大对象 + 统计/heap 观察）。

### 第 6 周：线程池与原子类/工具类（21–27）

- 21 `ThreadPoolExecutor`：参数含义、队列选择、拒绝策略、线程回收；用指标理解吞吐/延迟。
- 22 `ScheduledThreadPoolExecutor`：周期任务与漂移、异常处理。
- 23 `FutureTask`：状态机、取消、中断传播。
- 24 atomic 包：CAS、ABA、LongAdder 适用场景。
- 25–26 工具类：CountDownLatch/CyclicBarrier/Semaphore/Exchanger 的“典型用法模板”。
- 27 生产者-消费者：用 BlockingQueue 做标准解法；讨论背压与优雅停机。

期末综合（建议 1 个小项目）：
- “可配置线程池 + 生产者消费者 + 指标输出（吞吐/队列长度/耗时）”，并写一份选型说明。

## 检查点与验收标准（每章）

- 我能用自己的话解释本章 5 个关键词（不背定义，讲机制/边界）。
- 我能写出 1 个最小实验验证一个结论（含参数、输出、复盘）。
- 我能指出至少 2 个误区/坑，并说出“正确写法模板”。
- 我能回答 3 个场景题：该用什么工具、为什么、代价是什么。

## 记录模板（建议每章一条）

建议每章笔记文件：`notes/NN.<标题>.md`（题库：`notes/questions.md`）

```md
# 第 NN 章：<标题>

> 日期：YYYY-MM-DD
> 用时（分钟）：阅读__ / 自测__ / 实验__ / 笔记__
> 章节原文：`NN.<标题>/<章节主文档>.md`
> 配套实验：`labs/NN-xxx/`（如果有）
> 题库前缀：`CHNN-`（本章题目在 `notes/questions.md`）

## 0) 本章目标（1–2 句）
- 我这章要搞懂/能讲清楚什么？

## 1) 疑点清单（3–5 个，带状态/优先级）
- [待查][P1] Q1：……（定位：小节/关键词）
- [已解] Q2：……（结论：……；证据：章节小节/实验输出）
- [暂存][P2][前置: <概念/章节>][下次回看: <时间/章节>] Q3：……
  - 我当前猜想：……
  - 卡点：概念/机制/边界/源码
  - 证据：……（小节/现象/输出摘要）

## 2) 关键词（5–10 个）+ 一句话解释（写“保证什么/不保证什么”）
- 关键词A：……
- 关键词B：……

## 3) 核心机制链路（用步骤串起来）
- 触发条件 → 关键状态/字段 → 关键分支（A/B/C）→ 最终效果 → 边界

## 4) 关键结论（3 条）+ 适用边界/反例
- 结论1：……
  - 边界/反例：……
- 结论2：……
  - 边界/反例：……
- 结论3：……
  - 边界/反例：……

## 5) 我会怎么用在项目里（1 句）
- 在 <场景> 下，我会用 <工具/写法> 来 <目标>，并注意 <代价/边界>。

## 6) 自测回放（可选）
- 首轮总分：__/10（5题 * 0/1/2）
- 全量总分（可选）：__/20（10题 * 0/1/2）
- 错因分布：概念__ / 机制__ / 边界__ / 工程__
- 下一次复测优先自问的 5 个问题：……

## 7) 场景题（3 个）+ 我的答案（闭卷）
- 场景1：选型/原因/代价
- 场景2：选型/原因/代价
- 场景3：选型/原因/代价

## 8) 常见误区（2–5 条）+ 纠正要点
- 误区：……
  - 正确：……
  - 依据/信号：……

## 9) 最小实验（MRE）复盘（可复现）
- JDK：`java -version`（粘贴关键信息）
- 目录/命令：
- 参数：
- 观察点（3–6 条）：
- 结论（能推出什么）：
- 不能推出的结论（防止过度归因）：
- 下一步（1–2 条）：

## 10) 错题与复测（只记错题，题库只放题）
- CHNN-Qxx：<题干一句话>（归类：概念/机制/边界/工程）
  - 我当时的答案：……
  - 我漏了：A/B/C
  - 标准要点（3–5 条）：
  - D+1：
  - D+3：
  - D+7：
```

## 现有可用实验

- 第 1 章：`labs/01-concurrency-pros-cons/`（收益边界 + 数据竞争与修复）

> 后续每完成一章，就在 `labs/` 下新增对应章节目录，并在该目录 README 写清楚“如何跑、看什么、如何复盘”。 
