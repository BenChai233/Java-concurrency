# 并发编程学习/教学计划（基于本仓库 + Codex + JDK 21）

## 目标与产出

- 目标：系统掌握 Java 并发的核心概念、常见陷阱与工程落地选型（锁、AQS、并发容器、线程池、原子类、工具类）。
- 产出物（每章固定）：`自测题答案`、`最小可运行实验（labs/<chapter>/）`、`一页纸复盘`、`错题/误区清单`。

## 环境与约定

- JDK：21（建议统一使用同一套 JDK，运行前 `java -version` 确认）
- 实验目录：`labs/`（每章一个目录：`labs/01-...`、`labs/02-...`…）
- “只做可验证结论”：实验输出必须包含参数、结果校验、耗时；避免用不稳定现象推结论。

## 每章标准流程（建议 60–120 分钟/章）

1) **阅读**：通读章节 `.md`，标注“不懂/想验证/想反驳”的点（3–5 个）。
2) **Codex 自测**：让 Codex 生成 `10 题自测 + 误区清单 + 5 句话总结`；你先作答，再让 Codex 按要点评分。
3) **最小实验（MRE）**：每章 1–2 个实验（能跑、能复现、能解释）。把代码与输出交给 Codex 复盘。
4) **一页纸复盘**：写下本章：关键词、3 个结论、2 个误区、1 个“我会怎么用在项目里”。

> Codex 提示词模板（复制即用）
>
> - `基于本章内容，出10道自测题（含答案要点）+5个常见误区+5句话总结。`
> - `我先回答自测题（如下），请逐条评分并指出遗漏/错误，并给出纠正后的标准答案要点。`
> - `帮我设计一个最小可运行Java实验来验证：<结论>。要求：参数可调、输出可复盘、避免不稳定现象。`
> - `这是我的代码与输出（如下），请解释现象，并说明我能/不能从这个实验推出哪些结论。`

## 推荐进度（6 周路线，可按节奏拉长）

### 第 0 周：准备与基线

- 确认 JDK 21、生效的 `PATH/JAVA_HOME`、能 `javac`/`java` 运行。
- 跑通第 1 章实验：`labs/01-concurrency-pros-cons/`。
- 建一个学习记录文件（可在本地笔记或仓库外）：每章的“问题列表/结论/误区/实验参数与结果”。

### 第 1 周：基础与 JMM（01–03）

- 01 并发的优缺点：收益边界、代价清单、风险清单（已提供实验）。
- 02 线程状态/基本操作：创建方式、状态流转、interrupt 语义、join/daemon。
- 03 JMM 与 happens-before：可见性、有序性、重排序；建立“哪些行为由规范保证”。

实验建议：
- 线程状态：`WAITING/TIMED_WAITING/BLOCKED` 的最小复现与解释。
- JMM：用 `volatile`/非 `volatile` 的可见性对比（注意：避免用“死循环卡住”当唯一证据，需增加超时/统计）。

### 第 2 周：关键字与锁（04–07）

- 04 `synchronized`：monitor、可重入、happens-before、锁优化概念（以语义为主）。
- 05 `volatile`：可见性、禁止重排、与原子性边界。
- 06 `final`：初始化安全、发布与逃逸。
- 07 原子性/可见性/有序性总结：把概念映射到工具选择（锁/原子类/volatile）。

实验建议：
- `volatile` 的“可见但不原子”与 “原子但不复合”案例（如 check-then-act）。

### 第 3–4 周：Lock 体系与 AQS（08–13）

- 08–09 AQS：state/队列/条件队列、acquire/release 语义、共享/独占。
- 10 `ReentrantLock`：公平/非公平、可中断、tryLock、Condition。
- 11 `ReentrantReadWriteLock`：读写分离、饥饿与适用场景。
- 12 `Condition`：await/signal 的正确用法（必须 while 重新检查条件）。
- 13 `LockSupport`：park/unpark 与中断标记。

训练重点：
- 写出“正确的条件等待模板”（while + condition + state）。
- 用 3–5 个场景题练选型：synchronized vs Lock；RWLock 适合/不适合什么负载。

### 第 5 周：并发容器（14–20）

- 14 `ConcurrentHashMap`（JDK8 语义）：并发度、CAS/锁混合、迭代弱一致性。
- 15 `ConcurrentLinkedQueue`：无锁队列、吞吐与一致性。
- 16 `CopyOnWriteArrayList`：读多写少场景、内存与写放大。
- 17–18 `ThreadLocal`：使用边界、内存泄漏成因与最佳实践（及时 remove）。
- 19–20 `BlockingQueue`：背压、生产者消费者、不同队列权衡。

实验建议：
- ThreadLocal：用线程池复现“忘记 remove 导致对象滞留”的最小案例（可用大对象 + 统计/heap 观察）。

### 第 6 周：线程池与原子类/工具类（21–27）

- 21 `ThreadPoolExecutor`：参数含义、队列选择、拒绝策略、线程回收；用指标理解吞吐/延迟。
- 22 `ScheduledThreadPoolExecutor`：周期任务与漂移、异常处理。
- 23 `FutureTask`：状态机、取消、中断传播。
- 24 atomic 包：CAS、ABA、LongAdder 适用场景。
- 25–26 工具类：CountDownLatch/CyclicBarrier/Semaphore/Exchanger 的“典型用法模板”。
- 27 生产者-消费者：用 BlockingQueue 做标准解法；讨论背压与优雅停机。

期末综合（建议 1 个小项目）：
- “可配置线程池 + 生产者消费者 + 指标输出（吞吐/队列长度/耗时）”，并写一份选型说明。

## 检查点与验收标准（每章）

- 我能用自己的话解释本章 5 个关键词（不背定义，讲机制/边界）。
- 我能写出 1 个最小实验验证一个结论（含参数、输出、复盘）。
- 我能指出至少 2 个误区/坑，并说出“正确写法模板”。
- 我能回答 3 个场景题：该用什么工具、为什么、代价是什么。

## 记录模板（建议每章一条）

- 章节：`0X.<标题>`
- 关键结论（3 条）：
- 常见误区（2 条）：
- 实验：目录/命令/参数/输出摘要：
- 还没想明白的问题（下章前解决）：

## 现有可用实验

- 第 1 章：`labs/01-concurrency-pros-cons/`（收益边界 + 数据竞争与修复）

> 后续每完成一章，就在 `labs/` 下新增对应章节目录，并在该目录 README 写清楚“如何跑、看什么、如何复盘”。 
