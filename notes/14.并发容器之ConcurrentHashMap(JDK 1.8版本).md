# 第 14 章：并发容器之ConcurrentHashMap(JDK 1.8版本)

> 日期：2026-01-21
> 用时（分钟）：阅读 1h / 自测__ / 实验__ / 笔记__
> 章节原文：`并发容器之ConcurrentHashMap(JDK 1.8版本).md`
> 配套实验：`14-concurrenthashmap`
> 题库前缀：本章题目在 `notes/questions.md`

## 0) 本章目标（1–2 句）
- 我这章要搞懂/能讲清楚什么？

## 1) 疑点清单（3–5 个，带状态/优先级）
- [待查][P1] Q1：……（定位：小节/关键词）
- [已解] Q2：……（结论：……；证据：章节小节/实验输出）
- [暂存][P2][前置: <概念/章节>][下次回看: <时间/章节>] Q3：……
  - 我当前猜想：……
  - 卡点：概念/机制/边界/源码
  - 证据：……（小节/现象/输出摘要）

## 2) 关键词（5–10 个）+ 一句话解释（写“保证什么/不保证什么”）
- 关键词A：ConcurrentHashMap: 线程安全的map，保证并发下数据的正确性。
- 关键词B：链表：ConcurrentHashMap内table数组里的默认节点。
- 关键词C：红黑树：链表超过一定长度（8）时，链表转红黑树，提高查询效率。
- 关键词D：

## 3) 核心机制链路（用步骤串起来）
- 触发条件 → 关键状态/字段 → 关键分支（A/B/C）→ 最终效果 → 边界

## 4) 关键结论（3 条）+ 适用边界/反例
- 结论1：……
  - 边界/反例：……
- 结论2：……
  - 边界/反例：……
- 结论3：……
  - 边界/反例：……

## 5) 我会怎么用在项目里（1 句）
- 在 <场景> 下，我会用 <工具/写法> 来 <目标>，并注意 <代价/边界>。

## 6) 自测回放（可选）
- 总分：__/20（10题 * 0/1/2）
- 错因分布：概念__ / 机制__ / 边界__ / 工程__
- 下一次复测优先自问的 5 个问题：……

## 7) 场景题 + 我的答案
- 场景1：并发插入/删除下统计 map 大小用于监控与告警：选择 size() 还是 mappingCount()？为什么？
  - 选型：mappingCount()
  - 原因：因为 size() 是统计数组长度，mappingCount() 才是统计数组元素；
  - 代价：mappingCount()也是估算值，因为没有 stop-the-world 统计，结果不准。
- 场景2：怀疑长尾来自扩容：结合 addCount() 触发条件与扩容协作机制，如何设计最小复现实验验证？
  - 选型：初始化一个 ConcurrentHashMap，启动多个线程 addCount() 达到扩容因子（0.75 或指定因子），打印达到扩容因子这次 addCount() 耗时日志。
  - 原因：扩容是通过 addCount() 触发的，所以可以通过 addCount() 到扩容因子来验证扩容。
  - 代价：即使 addCount() 到扩容因子，结果也不准，因为扩容是异步的。

## 8) 常见误区（2–5 条）+ 纠正要点
- 误区：……
  - 正确：……
  - 依据/信号：……

## 9) 最小实验（MRE）复盘（可复现）
- JDK：`java -version`（粘贴关键信息）
- 目录/命令：
- 参数：
- 观察点（3–6 条）：
- 结论（能推出什么）：
- 不能推出的结论（防止过度归因）：
- 下一步（1–2 条）：

## 10) 错题与复测（只记错题，题库只放题）
- CH14-Q01（1/2）：对比 HashMap / Hashtable / Collections.synchronizedMap / ConcurrentHashMap(JDK 8)：线程安全手段与锁粒度差异。（归类：概念）
  - 我当时的答案：HashMap 线程不安全；Hashtable 用 synchronized 给所有操作加锁；synchronizedMap 只对 put 加 synchronized；CHM(JDK8) 分段锁，synchronized + CAS，只锁数组里的 Node。
  - 我漏了：synchronizedMap 基本所有方法都用同一把 mutex 锁（读也会锁，迭代还需外部同步）；JDK8 CHM 已移除 Segment（不是分段锁）；CHM 读多为无锁、写按桶（bin）锁 + 空桶 CAS 的关键差异。
  - 标准要点（3–5 条）：
    - HashMap：非线程安全，并发 put/resize 可能出现数据丢失/结构破坏等问题。
    - Hashtable：通过 synchronized（整表/对象锁）保证线程安全，锁粒度粗、并发度低。
    - Collections.synchronizedMap：外层包装对每个方法 synchronized(mutex)；迭代需在外部对同一 mutex 同步。
    - ConcurrentHashMap(JDK8)：CAS + synchronized(桶头) + volatile 读；扩容支持多线程协作（遇到 MOVED/ForwardingNode 会 helpTransfer）。

- CH14-Q02（1/2）：ConcurrentHashMap 的 table 数组里可能出现哪些节点形态（Node / TreeBin / ForwardingNode…），它们分别代表什么语义？（归类：概念）
  - 我当时的答案：Node 是数组里的元素（链表/红黑树根）；TreeBin 是 Node 节点下的树节点；ForwardingNode 是扩容时的重定向临时节点。
  - 我漏了：TreeNode 才是红黑树真实节点，TreeBin 是“树桶容器/桶头”；桶头 hash 的符号（fh>=0 链表，fh<0 树/特殊节点）这一判断口径；ForwardingNode 的 MOVED 语义与 nextTable 引导。
  - 标准要点（3–5 条）：
    - Node：基础节点/链表节点，table[i] 可能直接是链表头 Node。
    - TreeNode：红黑树真实节点（parent/left/right/prev/red 等）。
    - TreeBin：树桶容器（table[i] 指向它），内部持有 root/first/lockState 等管理整棵树与并发控制。
    - ForwardingNode：扩容占位（hash==MOVED，持有 nextTable），表示该桶已迁移/正在迁移并引导 helpTransfer。

- CH14-Q03（0/2）：sizeCtl 在为 -1、-N、0、正数时分别表示什么状态？在初始化与扩容流程的哪些节点被读/写？（归类：机制）
  - 我当时的答案：-1 表示正在扩容；-N 表示扩容大小；0 表示初始化状态；正数表示数组大小。
  - 我漏了：-1 是“正在初始化 table”；-N 是“扩容进行中且有 N-1 个线程参与扩容”（不是扩容大小）；正数在“未初始化/已初始化”阶段语义不同（期望容量 vs 阈值/可用容量≈0.75n）；构造器/initTable/addCount/transfer(finishing) 等关键读写点。
  - 标准要点（3–5 条）：
    - -1：table 初始化中（initTable 通过 CAS 抢初始化权）。
    - -N：扩容中，且有 N-1 个线程在协作迁移（并发扩容控制状态）。
    - 0：默认控制值（未初始化时的默认状态）。
    - 正数：未初始化时可表示期望表容量；初始化后一般表示扩容阈值/可用容量（如 n-(n>>>2)）。
    - 读写位置：构造器预置 sizeCtl；initTable 写 -1 并最终写阈值；addCount 比较 sumCount 与 sizeCtl 决定扩容并更新控制状态；transfer finishing 更新 table/sizeCtl。

- CH14-Q04（1/2）：putVal 主流程中，哪些步骤走 CAS，哪些步骤走 synchronized？各自保护的共享数据/临界区是什么？（归类：机制）
  - 我当时的答案：数组元素走 CAS；修改元素下的节点值走 synchronized；CAS 临界区是数组元素，synchronized 临界区是节点数据。
  - 我漏了：CAS 不只发生在“数组元素”，还包括 initTable(sizeCtl)、计数(baseCount/CounterCell)、扩容控制(sizeCtl/transferIndex)；synchronized 主要是锁桶头 f，保护链表/树的结构性修改（遍历插入/替换/树化等）。
  - 标准要点（3–5 条）：
    - CAS：initTable 抢初始化权（sizeCtl）；空桶 casTabAt 直接插入；addCount 更新 baseCount/CounterCell；扩容时 CAS 更新 sizeCtl/transferIndex 等控制字段。
    - synchronized：非空桶时 synchronized(f) 锁桶头，互斥修改该 bin（链表插入/替换 value、TreeBin 插入、treeifyBin 等）。
    - 临界区划分：CAS 侧偏“字段/槽位原子更新”；synchronized 侧偏“桶内结构性变更的互斥”。

- CH14-Q05（1/2）：扩容 transfer 过程中，transferIndex、stride、ForwardingNode(MOVED) 的角色分别是什么？多线程如何避免重复迁移同一个桶？（归类：机制）
  - 我当时的答案：transferIndex 表示需要迁移的地址；ForwardingNode 表示移动的节点；根据 ForwardingNode 标记节点避免重复迁移。
  - 我漏了：stride 是每个线程一次认领/处理的区间步长；transferIndex 是全局进度指针（CAS 领取区间）；避免重复迁移依赖“CAS 领取 + 桶迁移后写 fwd(MOVED) 标记 + 看到 MOVED 的 helpTransfer/跳过”。
  - 标准要点（3–5 条）：
    - transferIndex：全局迁移进度指针，多线程用 CAS 领取迁移区间。
    - stride：每个线程一次处理的桶数量（分段领取），用于均衡并行迁移开销。
    - ForwardingNode(MOVED)：旧表桶位的迁移完成标记（持有 nextTable）。
    - 避免重复迁移：CAS 领取区间 + 迁移后 tab[i]=fwd 标记 + 其他线程遇到 MOVED 直接跳过/协助迁移。

- CH14-Q06（1/2）：并发插入/删除下统计 map 大小用于监控与告警：选择 size() 还是 mappingCount()？为什么？（归类：边界/工程）
  - 我当时的答案：选 mappingCount()；因为 size() 是统计数组长度，mappingCount() 才是统计数组元素；但它也是估算值，因为没有 stop-the-world 统计。
  - 我漏了：size() 也不是数组长度，而是基于 sumCount 的“元素个数估算”；mappingCount 与 size 的核心差别是返回类型 long vs int（以及 size 的溢出处理/官方推荐用法）。
  - 标准要点（3–5 条）：
    - size()：sumCount() 的估计值转 int，可能发生饱和/截断（>Integer.MAX_VALUE）。
    - mappingCount()：同样基于 sumCount()，返回 long，官方更推荐用于表达映射数量。
    - 两者在并发下都是估计值；若需要强一致计数需额外协议/外部统计。

- CH14-Q07（1/2）：怀疑长尾来自扩容：结合 addCount() 触发条件与扩容协作机制，如何设计最小复现实验验证？（归类：场景/工程）
  - 我当时的答案：初始化一个 ConcurrentHashMap，启动多个线程 addCount() 达到扩容因子（0.75 或指定因子），打印达到扩容因子这次 addCount() 耗时日志。
  - 我漏了：业务侧不能直接调用 addCount，应通过大量 put/remove 触发；需要对照组（足够大初始容量 vs 小初始容量）+ 统计分位数（p99/p999）+ 观测扩容窗口（nextTable!=null 或 sizeCtl<0）并与延迟尖峰关联；扩容期间 put 可能 helpTransfer。
  - 标准要点（3–5 条）：
    - 用 put 写入触发阈值（≈0.75n）并导致扩容，而不是直接调用 addCount。
    - 对照组：预设大容量（尽量不扩容）vs 小容量（频繁扩容），保持线程数/操作量一致。
    - 记录每次 put 的耗时分布（p95/p99/p999），找长尾尖峰。
    - 观测是否处于扩容（如 nextTable!=null 或 sizeCtl<0），把尖峰与扩容窗口做关联。
    - 结论：扩容/协作迁移窗口内出现显著长尾，支持“扩容导致长尾”的假设。

- CH14-Q08（1/2）：代码阅读：spread `(h ^ (h >>> 16)) & HASH_BITS` 解决什么问题？n=16 时 `i=(n-1)&spread(h)` 的取值范围是什么？（归类：代码阅读）
  - 我当时的答案：为了降低 hash 冲突，使元素在数组内分布均匀。
  - 我漏了：n=16 时 i 的范围应为 0..15；spread 的具体动作是“把高 16 位混入低 16 位”；`& HASH_BITS` 的掩码作用（保留有效 hash 位）。
  - 标准要点（3–5 条）：
    - 目的：让 hash 更均匀，降低桶冲突，尤其因为索引计算主要用低位。
    - 做法：`h ^ (h>>>16)` 将高 16 位信息混入低 16 位。
    - `& HASH_BITS`：掩码保留有效 hash 位（实现层面的有效位约束）。
    - n=16：`i = 15 & spread(h)`，因此 i 的取值范围是 0..15。

- CH14-Q09（1/2）：代码阅读：tableSizeFor 返回的是什么？c=18/16/1/0 分别返回什么？（归类：代码阅读）
  - 我当时的答案：返回 >=c 的最接近 2 的幂；18→32，16→16，1→1，0→0。
  - 我漏了：c=0 的返回值应为 1（n=c-1=-1 命中 n<0 分支）；并且需注意最大容量上限（MAXIMUM_CAPACITY）。
  - 标准要点（3–5 条）：
    - 返回值：大于等于 c 的最小 2 的幂（并受最大容量限制）。
    - c=18 → 32。
    - c=16 → 16。
    - c=1 → 1。
    - c=0 → 1。

- CH14-Q10（0/2）：代码阅读：迁移时为何按 `(ph & n)` 分两部分并落在 nextTable 的 i 与 i+n？`setTabAt(tab,i,fwd)` 的语义是什么？（归类：代码阅读/机制）
  - 我当时的答案：未作答。
  - 我漏了：扩容从 n 到 2n 时元素新位置只可能是 i 或 i+n；用 `(ph & n)` 判断走 low/high；`tab[i]=fwd` 用于标记已迁移并引导并发读写到 nextTable/触发 helpTransfer。
  - 标准要点（3–5 条）：
    - 扩容后索引变化：容量从 n→2n，新索引要么仍为 i，要么变为 i+n。
    - 判定依据：看 hash 在“旧容量位 n”上的那一 bit，即 `(ph & n)`；0 归入 low（留在 i），非 0 归入 high（去 i+n）。
    - 落位规则：low 链/树放入 `nextTable[i]`，high 链/树放入 `nextTable[i+n]`。
    - `setTabAt(tab,i,fwd)`：把旧表该桶置为 ForwardingNode(MOVED)，表示桶已迁移/正在迁移，防重复迁移并引导并发访问走 nextTable（必要时 helpTransfer）。
